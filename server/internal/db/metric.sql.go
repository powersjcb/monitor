// Code generated by sqlc. DO NOT EDIT.
// source: metric.sql

package db

import (
	"context"
)

const getMetrics = `-- name: GetMetrics :many
select distinct(m.source)
from public.metrics m
`

// list of all current metrics names
func (q *Queries) GetMetrics(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getMetrics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var source string
		if err := rows.Scan(&source); err != nil {
			return nil, err
		}
		items = append(items, source)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const metricForSource = `-- name: MetricForSource :many
select source, ts, inserted_at, name, value
from public.metrics
where source = $1
`

func (q *Queries) MetricForSource(ctx context.Context, source string) ([]Metric, error) {
	rows, err := q.db.QueryContext(ctx, metricForSource, source)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Metric
	for rows.Next() {
		var i Metric
		if err := rows.Scan(
			&i.Source,
			&i.Ts,
			&i.InsertedAt,
			&i.Name,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const metricStatsPerPeriod = `-- name: MetricStatsPerPeriod :many
select m.source,
       m.name,
       to_timestamp(floor((extract('epoch' from m.ts) / $1::int)) * $1::int) ts,
       avg(m.value) avg,
       max(m.value) max,
       min(m.value) min
from public.metrics m
group by m.source, m.name, ts_bucket
`

type MetricStatsPerPeriodRow struct {
	Source string      `json:"source"`
	Name   string      `json:"name"`
	Ts     interface{} `json:"ts"`
	Avg    interface{} `json:"avg"`
	Max    interface{} `json:"max"`
	Min    interface{} `json:"min"`
}

func (q *Queries) MetricStatsPerPeriod(ctx context.Context, seconds int32) ([]MetricStatsPerPeriodRow, error) {
	rows, err := q.db.QueryContext(ctx, metricStatsPerPeriod, seconds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MetricStatsPerPeriodRow
	for rows.Next() {
		var i MetricStatsPerPeriodRow
		if err := rows.Scan(
			&i.Source,
			&i.Name,
			&i.Ts,
			&i.Avg,
			&i.Max,
			&i.Min,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
